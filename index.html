<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mahammadali Zamani - 3D Resume Portfolio</title>
    <style>
        /* Ensure 3D canvas doesn't block UI */
    canvas {
        position: absolute;
        z-index: 1 !important;
        pointer-events: auto;
    }
    
    /* Ensure all UI elements are above canvas */
    #hint, #controls, #loading, #section-info {
        position: fixed !important;
        z-index: 9999 !important;
        pointer-events: auto !important;
    }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #9b2948 0%, #ff7251 100%);
        }

        .section-info a:hover {
            color: #ffedbf !important;
            border-bottom: 1px solid #ffedbf !important;
            transition: all 0.2s ease;
        }

        #section-info {
            position: fixed;
            top: 20px;
            right: -400px; /* Start completely off-screen to the right */
            width: 350px;
            color: #ffedbf;
            background: rgba(155, 41, 72, 0.98);
            padding: 20px;
            border-radius: 12px;
            z-index: 9999;
            max-height: 80vh;
            overflow-y: auto;
            display: block; /* Always display block, just positioned off-screen */
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 237, 191, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: right 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 1; /* Ensure it's visible when on screen */
            pointer-events: auto; /* Ensure it's clickable */
        }

        #section-info.show {
            right: 20px; /* Slide in to position */
        }

        #section-info.panel-show {
            right: 20px; /* Slide in to visible position */
        }

        /* Add fade-in animation for content */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-content-animate > * {
            animation: fadeInUp 0.5s ease-out forwards;
            opacity: 0;
        }

        .section-content-animate > *:nth-child(1) { animation-delay: 0.1s; }
        .section-content-animate > *:nth-child(2) { animation-delay: 0.2s; }
        .section-content-animate > *:nth-child(3) { animation-delay: 0.3s; }
        .section-content-animate > *:nth-child(4) { animation-delay: 0.4s; }
        .section-content-animate > *:nth-child(5) { animation-delay: 0.5s; }
        .section-content-animate > *:nth-child(6) { animation-delay: 0.6s; }

        /* Ensure all children of section-content have proper transitions */
        #section-content {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #section-content > * {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .section-title {
            color: #ffcd74;
            margin-bottom: 15px;
            font-size: 1.6em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .project-item {
            background: rgba(255, 114, 81, 0.4);
            padding: 12px 15px;
            margin: 12px 0;
            border-radius: 8px;
            border-left: 4px solid #ffcd74;
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .project-item:hover {
            background: rgba(255, 114, 81, 0.6);
            transform: translateX(5px);
        }

        .project-item h4 {
            color: #ffedbf;
            margin-bottom: 5px;
        }

        .project-item p {
            color: #ffca7b;
            font-size: 0.95em;
            margin-bottom: 5px;
        }

        .project-item small {
            color: rgba(255, 237, 191, 0.7);
            font-size: 0.85em;
        }

        .contact-info {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 114, 81, 0.3);
            border-radius: 6px;
        }

        .contact-icon {
            font-size: 20px;
            margin-right: 10px;
            width: 30px;
            text-align: center;
        }

        .contact-detail {
            flex: 1;
        }

        .skill-category {
            margin-bottom: 15px;
        }

        .skill-category h4 {
            color: #ffcd74;
            margin-bottom: 8px;
        }

        .skill-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .skill-tag {
            background: rgba(255, 114, 81, 0.4);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9em;
            border: 1px solid rgba(255, 237, 191, 0.2);
        }

        .profile-photo {
            width: 100%;
            max-width: 250px;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            border: 3px solid #ffcd74;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffedbf;
            z-index: 100;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #9b2948 0%, #ff7251 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffedbf;
            font-size: 24px;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 237, 191, 0.3);
            border-radius: 50%;
            border-top-color: #ffcd74;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Style for the close button to make it more visible */
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff7251;
            color: #ffedbf;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .close-btn:hover {
            background: #ff5251;
            transform: scale(1.1);
        }


        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            pointer-events: none;
        }

        #touch-indicator {
            width: 80px;
            height: 80px;
            position: relative;
        }

        .touch-circle {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 237, 191, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
        }

        .touch-circle.active {
            border-color: #ffcd74;
            box-shadow: 0 0 20px rgba(255, 205, 116, 0.6);
            transform: translate(-50%, -50%) scale(1.2);
        }

        .touch-arrow {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid rgba(255, 205, 116, 0.7);
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: all 0.2s ease;
        }

        .touch-arrow.show {
            opacity: 1;
        }

        .touch-arrow.left {
            transform: translateX(-50%) rotate(-90deg);
        }

        .touch-arrow.right {
            transform: translateX(-50%) rotate(90deg);
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #section-info {
                width: 90%;
                max-width: 350px;
                right: -100%;
                top: 10px;
                max-height: 70vh;
                font-size: 14px;
            }

            #section-info.panel-show {
                right: 5%;
            }

            .section-title {
                font-size: 1.3em;
            }

            .project-item {
                padding: 10px 12px;
                font-size: 0.9em;
            }

            #hint {
                font-size: 14px;
                padding: 8px 15px;
                top: 10px;
            }

            #controls {
                display: none; /* Hide WASD hint on mobile */
            }

            .close-btn {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }
        }

        /* Prevent text selection on mobile */
        @media (hover: none) and (pointer: coarse) {
            body {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-touch-callout: none;
            }
        }

        /* Ensure canvas is touchable on mobile */
        canvas {
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }


        #hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffedbf;
            background: rgba(155, 41, 72, 0.85);
            padding: 10px 20px;
            border-radius: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 237, 191, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        
        #boundary-warning {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffcd74;
            background: rgba(155, 41, 72, 0.9);
            padding: 10px 20px;
            border-radius: 12px;
            z-index: 100;
            display: none;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 237, 191, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .highlighted-section {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div id="hint">
        <span id="hint-desktop">‚ö° Use WASD to drive into colored sections</span>
        <span id="hint-mobile" style="display: none;">üëÜ Hold to drive, swipe to turn</span>
    </div>

    <div id="mobile-controls" style="display: none;">
        <div id="touch-indicator">
            <div class="touch-circle"></div>
            <div class="touch-arrow"></div>
        </div>
    </div>

    <div id="section-info">
        <!-- <button class="close-btn" onclick="window.hideSectionInfo()">‚úï</button> -->
        <button class="close-btn" onclick="window.hideSectionInfo()" ontouchstart="window.hideSectionInfo()">‚úï</button>
        <div id="section-content"></div>
    </div>

    <div id="controls">
        use WASD
    </div>

    <div id="loading">
        <div class="loading-spinner"></div>
        <div>Loading 3D Environment...</div>
    </div>
    

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup - NO FOG
        const scene = new THREE.Scene();
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);

        // Camera setup - START WITH ZOOMED OUT VIEW
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        
        // Initial zoomed-out position to see all sections
        camera.position.set(0, 80, 80);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000, 1);

        // Add this line to set canvas z-index
        renderer.domElement.style.zIndex = '1';
        renderer.domElement.style.position = 'absolute';

        document.body.appendChild(renderer.domElement);


        // Orbit controls for isometric view
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;

        controls.enablePan = false;
        controls.enabled = !isMobile; // Disable orbit controls on mobile for better touch handling



        controls.minDistance = 30;
        controls.maxDistance = 150;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minPolarAngle = Math.PI / 6;
        controls.target.set(0, 0, 0);
        controls.update();

        // Define play area boundaries (match ground size)
        const BOUNDARY = {
            minX: -50,
            maxX: 50,
            minZ: -50,
            maxZ: 50
        };

        // Resume Sections Data with Mahammadali's real information
        const sections = {
            profile: {
                position: new THREE.Vector3(0, 0, 0), // Center position
                size: new THREE.Vector2(18, 18), // Larger size for center section
                color: 0xff7251,
                title: "üë§ Profile",
                icon: "üë§",
                buildingType: "center",
                content: `
                    <h3 class="section-title">Mahammadali Zamani</h3>
                    <img src="profile.jpg" alt="Mahammadali Zamani" class="profile-photo" onerror="this.style.display='none'">
                    <div class="project-item">
                        <h4>Computer Science Student & Software Engineer</h4>
                        <p>Passionate developer specializing in backend systems, physics simulations, and high-performance computing.</p>
                    </div>
                    <div class="contact-info">
                        <div class="contact-icon">üì±</div>
                        <div class="contact-detail">+994-55-397-75-00</div>
                    </div>
                    <div class="contact-info">
                        <div class="contact-icon">üìß</div>
                        <div class="contact-detail"><a href="mailto:zamanli.mehemmedeli@gmail.com" style="color: #ffca7b; text-decoration: none; border-bottom: 1px dotted #ffca7b;">zamanli.mehemmedeli@gmail.com</a></div>
                    </div>
                    <div class="contact-info">
                        <div class="contact-icon">üîó</div>
                        <div class="contact-detail"><a href="https://www.linkedin.com/in/mahammadali-zamanli-64931a282/" target="_blank" style="color: #ffca7b; text-decoration: none; border-bottom: 1px dotted #ffca7b;">LinkedIn</a></div>
                    </div>
                    <div class="contact-info">
                        <div class="contact-icon">üíª</div>
                        <div class="contact-detail"><a href="https://github.com/Mahammadali12" target="_blank" style="color: #ffca7b; text-decoration: none; border-bottom: 1px dotted #ffca7b;">GitHub</a></div>
                    </div>
                    <div class="contact-info">
                        <div class="contact-icon">üìç</div>
                        <div class="contact-detail">Baku, Azerbaijan</div>
                    </div>
                    <div class="project-item" style="margin-top: 20px;">
                        <p><strong>"Engineering elegant solutions to complex problems."</strong></p>
                    </div>
                `
            },
            education: {
                position: new THREE.Vector3(30, 0, -30),
                size: new THREE.Vector2(15, 15),
                color: 0x9b2948,
                title: "üéì Education",
                icon: "üéì",
                buildingType: "university",
                content: `
                    <h3 class="section-title">Education</h3>
                    <div class="project-item">
                        <h4>ADA University</h4>
                        <p>Bachelor of Arts in Computer Science</p>
                        <p><strong>Baku, Azerbaijan</strong> | Sep 2022 ‚Äì May 2027</p>
                    </div>
                    <div class="project-item">
                        <h4>Transport and Telecommunication Institute</h4>
                        <p>Bachelor of Applied Science in Computer Science (Exchange Program)</p>
                        <p><strong>Riga, Latvia</strong> | Feb 2025 ‚Äì June 2025</p>
                    </div>
                    <div class="project-item">
                        <h4>Relevant Coursework</h4>
                        <p>Data Structures and Algorithms, Object-Oriented Programming (Java), Operating Systems, Computer Networks, Database Systems, Discrete Mathematics, Probability and Statistics, Software Engineering Principles</p>
                    </div>
                `
            },
            experience: {
                position: new THREE.Vector3(-30, 0, 30),
                size: new THREE.Vector2(15, 15),
                color: 0xffca7b,
                title: "üíº Experience",
                icon: "üíº",
                buildingType: "office",
                content: `
                    <h3 class="section-title">Work Experience</h3>
                    <div class="project-item">
                        <h4>Software Engineer Intern - AzSimX Azersilah</h4>
                        <p><strong>Baku, Azerbaijan</strong> | July 2025 ‚Äì Dec 2025</p>
                        <p>‚Ä¢ Engineered a high-fidelity physics simulation module in C# (Unity), increasing aerodynamic calculation accuracy by 15% and eliminating trajectory drift by 22% compared to engine defaults.</p>
                        <p>‚Ä¢ Optimized real-time rendering and calculation loops, maintaining a stable 90 FPS in VR and reducing average frame latency from 14ms to 9ms through profiling and bottleneck elimination.</p>
                        <p>‚Ä¢ Designed software interface for hardware integration, achieving sub-millisecond response times and improving hardware-to-software synchronization reliability by 30%.</p>
                    </div>
                `
            },
            projects: {
                position: new THREE.Vector3(30, 0, 30),
                size: new THREE.Vector2(15, 15),
                color: 0xffcd74,
                title: "üöÄ Projects",
                icon: "üöÄ",
                buildingType: "lab",
                content: `
                    <h3 class="section-title">Technical Projects</h3>
                    <div class="project-item">
                        <h4>HTTP Web Server | C, POSIX, Socket programming</h4>
                        <p>‚Ä¢ Architected a multithreaded HTTP server in C handling 1,000+ concurrent connections with average response times under 50ms.</p>
                        <p>‚Ä¢ Reduced memory overhead by 40% by implementing a custom thread-pool and request parser, ensuring stability under high-throughput conditions.</p>
                        <p>‚Ä¢ Implemented HTTP/1.1 persistent connections, resulting in a 25% reduction in TCP handshake overhead for multi-request sessions.</p>
                    </div>
                    <div class="project-item">
                        <h4>Task Manager REST API | Go, net/http, JSON</h4>
                        <p>‚Ä¢ Developed a concurrent REST API in Go, utilizing Goroutines and Channels to increase request throughput by 4x compared to synchronous processing.</p>
                        <p>‚Ä¢ Improved maintainability and test coverage by 35% by implementing Hexagonal Architecture, decoupling domain logic for isolated unit testing.</p>
                        <p>‚Ä¢ Eliminated race conditions during high-concurrency tasks, ensuring 100% data integrity across 500+ automated stress tests.</p>
                    </div>
                    <div class="project-item">
                        <h4>Web Scraper Application | Java, Jsony, Spring Boot, PostgreSQL, Docker</h4>
                        <p>‚Ä¢ Built a containerized data extraction pipeline that increased collection speed by 60%, parsing 200+ structured records per minute to PostgreSQL.</p>
                        <p>‚Ä¢ Designed an extensible API architecture for rapid onboarding of new scraping targets, reducing new model integration time by 50%.</p>
                        <p>‚Ä¢ Reduced deployment configuration time by 80% by orchestrating the full stack with Docker Compose for consistent environment parity.</p>
                    </div>
                `
            },
            skills: {
                position: new THREE.Vector3(-30, 0, -30),
                size: new THREE.Vector2(15, 15),
                color: 0xffedbf,
                title: "‚ö° Skills",
                icon: "‚ö°",
                buildingType: "tower",
                content: `
                    <h3 class="section-title">Technical Skills</h3>
                    <div class="skill-category">
                        <h4>Programming Languages</h4>
                        <div class="skill-list">
                            <span class="skill-tag">Java</span>
                            <span class="skill-tag">Go</span>
                            <span class="skill-tag">SQL (PostgreSQL)</span>
                            <span class="skill-tag">C#</span>
                            <span class="skill-tag">C</span>
                        </div>
                    </div>
                    <div class="skill-category">
                        <h4>Frameworks & Libraries</h4>
                        <div class="skill-list">
                            <span class="skill-tag">Spring Boot</span>
                            <span class="skill-tag">Unity</span>
                            <span class="skill-tag">JUnit</span>
                            <span class="skill-tag">Jsony</span>
                            <span class="skill-tag">POSIX Sockets</span>
                        </div>
                    </div>
                    <div class="skill-category">
                        <h4>Tools & DevOps</h4>
                        <div class="skill-list">
                            <span class="skill-tag">Git</span>
                            <span class="skill-tag">Docker</span>
                            <span class="skill-tag">Docker Compose</span>
                            <span class="skill-tag">Linux (Bash)</span>
                            <span class="skill-tag">Postman</span>
                            <span class="skill-tag">Maven</span>
                        </div>
                    </div>
                    <div class="skill-category">
                        <h4>Languages</h4>
                        <div class="skill-list">
                            <span class="skill-tag">Azerbaijani (Native)</span>
                            <span class="skill-tag">English (Fluent)</span>
                            <span class="skill-tag">Russian (Working Proficiency)</span>
                        </div>
                    </div>
                `
            }
        };

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffedbf, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffedbf, 1.2);
        directionalLight.position.set(20, 40, 15);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -40;
        directionalLight.shadow.camera.right = 40;
        directionalLight.shadow.camera.top = 40;
        directionalLight.shadow.camera.bottom = -40;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create ground with warm color
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffedbf,
            side: THREE.DoubleSide,
            shininess: 30
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add grid helper for better orientation
        const gridHelper = new THREE.GridHelper(100, 20, 0x9b2948, 0x9b2948);
        gridHelper.position.y = 0.01;
        gridHelper.material.opacity = 0.15;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // Create section markers and labels
        const sectionMeshes = [];
        const sectionLabels = [];
        const sectionBuildings = [];

        // Function to create low poly buildings
        function createLowPolyBuilding(type, color, position) {
            const buildingGroup = new THREE.Group();
            const baseColor = color;
            
            switch(type) {
                case 'center': // Main profile building
                    // Main base
                    const baseGeometry1 = new THREE.BoxGeometry(5, 10, 5);
                    const baseMaterial1 = new THREE.MeshPhongMaterial({ 
                        color: baseColor,
                        shininess: 30
                    });
                    const base1 = new THREE.Mesh(baseGeometry1, baseMaterial1);
                    base1.position.y = 5;
                    base1.castShadow = true;
                    base1.receiveShadow = true;
                    buildingGroup.add(base1);
                    
                    // Pyramid roof
                    const pyramidGeometry = new THREE.ConeGeometry(3.5, 4, 4);
                    const pyramidMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x9b2948,
                        shininess: 20
                    });
                    const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                    pyramid.position.y = 12;
                    pyramid.castShadow = true;
                    buildingGroup.add(pyramid);
                    
                    // Decorative windows
                    for(let i = 0; i < 4; i++) {
                        const windowGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.1);
                        const windowMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0xffcd74,
                            emissive: 0xffcd74,
                            emissiveIntensity: 0.3
                        });
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            i % 2 === 0 ? -1.5 : 1.5,
                            3 + Math.floor(i/2) * 3,
                            2.6
                        );
                        buildingGroup.add(window);
                    }
                    break;
                    
                case 'university': // Education building
                    // Wide base
                    const baseGeometry2 = new THREE.BoxGeometry(7, 8, 7);
                    const baseMaterial2 = new THREE.MeshPhongMaterial({ 
                        color: baseColor,
                        shininess: 30
                    });
                    const base2 = new THREE.Mesh(baseGeometry2, baseMaterial2);
                    base2.position.y = 4;
                    base2.castShadow = true;
                    base2.receiveShadow = true;
                    buildingGroup.add(base2);
                    
                    // Flat roof with railing
                    const roofGeometry = new THREE.BoxGeometry(8, 0.5, 8);
                    const roofMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x3a1c00
                    });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 8.25;
                    buildingGroup.add(roof);
                    
                    // Columns
                    for(let i = 0; i < 4; i++) {
                        const columnGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2);
                        const columnMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0xffcd74
                        });
                        const column = new THREE.Mesh(columnGeometry, columnMaterial);
                        const angle = (i / 4) * Math.PI * 2;
                        column.position.set(
                            Math.cos(angle) * 2.5,
                            5,
                            Math.sin(angle) * 2.5
                        );
                        buildingGroup.add(column);
                    }
                    break;
                    
                case 'office': // Experience building
                    // Modern office tower
                    const towerGeometry = new THREE.BoxGeometry(4, 14, 4);
                    const towerMaterial = new THREE.MeshPhongMaterial({ 
                        color: baseColor,
                        shininess: 40
                    });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.y = 7;
                    tower.castShadow = true;
                    tower.receiveShadow = true;
                    buildingGroup.add(tower);
                    
                    // Office windows grid
                    for(let i = 0; i < 3; i++) {
                        for(let j = 0; j < 4; j++) {
                            const officeWindowGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.1);
                            const officeWindowMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0x00a8ff,
                                emissive: 0x00a8ff,
                                emissiveIntensity: 0.4
                            });
                            const officeWindow = new THREE.Mesh(officeWindowGeometry, officeWindowMaterial);
                            officeWindow.position.set(
                                -1.2 + i * 1.2,
                                3 + j * 2.5,
                                2.1
                            );
                            buildingGroup.add(officeWindow);
                        }
                    }
                    
                    // Rooftop structure
                    const rooftopGeometry = new THREE.BoxGeometry(5, 2, 5);
                    const rooftopMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x3a1c00
                    });
                    const rooftop = new THREE.Mesh(rooftopGeometry, rooftopMaterial);
                    rooftop.position.y = 15;
                    buildingGroup.add(rooftop);
                    break;
                    
                case 'lab': // Projects building
                    // Main lab structure
                    const labBaseGeometry = new THREE.BoxGeometry(6, 6, 6);
                    const labBaseMaterial = new THREE.MeshPhongMaterial({ 
                        color: baseColor,
                        shininess: 35
                    });
                    const labBase = new THREE.Mesh(labBaseGeometry, labBaseMaterial);
                    labBase.position.y = 3;
                    labBase.castShadow = true;
                    labBase.receiveShadow = true;
                    buildingGroup.add(labBase);
                    
                    // Dome on top
                    const domeGeometry = new THREE.SphereGeometry(3.5, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
                    const domeMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x00a8ff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                    dome.position.y = 9;
                    dome.rotation.x = Math.PI;
                    buildingGroup.add(dome);
                    
                    // Antenna
                    const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                    const antennaMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x333333
                    });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = 12.5;
                    buildingGroup.add(antenna);
                    break;
                    
                case 'tower': // Skills building
                    // Tall skill tower
                    const skillTowerGeometry = new THREE.BoxGeometry(3, 16, 3);
                    const skillTowerMaterial = new THREE.MeshPhongMaterial({ 
                        color: baseColor,
                        shininess: 50
                    });
                    const skillTower = new THREE.Mesh(skillTowerGeometry, skillTowerMaterial);
                    skillTower.position.y = 8;
                    skillTower.castShadow = true;
                    skillTower.receiveShadow = true;
                    buildingGroup.add(skillTower);
                    
                    // Decorative rings
                    for(let i = 0; i < 3; i++) {
                        const ringGeometry = new THREE.TorusGeometry(2.2, 0.3, 8, 12);
                        const ringMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0xffcd74
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.position.y = 3 + i * 5;
                        ring.rotation.x = Math.PI / 2;
                        buildingGroup.add(ring);
                    }
                    
                    // Spire on top
                    const spireGeometry = new THREE.ConeGeometry(0.5, 4, 4);
                    const spireMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffffff,
                        emissive: 0xffffff,
                        emissiveIntensity: 0.2
                    });
                    const spire = new THREE.Mesh(spireGeometry, spireMaterial);
                    spire.position.y = 20;
                    buildingGroup.add(spire);
                    break;
            }
            
            // Position the building
            buildingGroup.position.set(position.x, 0, position.z);
            
            return buildingGroup;
        }

        Object.keys(sections).forEach(key => {
            const section = sections[key];
            
            // Section base (ground plate)
            const geometry = new THREE.BoxGeometry(section.size.x, 0.5, section.size.y);
            const material = new THREE.MeshPhongMaterial({ 
                color: section.color,
                transparent: true,
                opacity: 0.9, // More opaque for better visibility
                emissive: section.color,
                emissiveIntensity: 0.4 // Increased for center section
            });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(section.position.x, 0.25, section.position.z);
            box.userData = { type: 'section', id: key };
            box.castShadow = true;
            box.receiveShadow = true;
            
            // Make center section (profile) pulse with animation
            if (key === 'profile') {
                material.emissiveIntensity = 0.6;
                // Add glowing effect to center section
                const glowGeometry = new THREE.BoxGeometry(section.size.x + 1, 0.1, section.size.y + 1);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: section.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.05;
                box.add(glow);
            }
            
            scene.add(box);
            sectionMeshes.push(box);

            // Add border
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                color: 0x3a1c00, // Dark brown for better contrast
                linewidth: 2 
            }));
            box.add(line);

            // Create billboard label that always faces camera
            createBillboardLabel(section);
            
            // Create low poly building for this section
            const building = createLowPolyBuilding(section.buildingType, section.color, section.position);
            scene.add(building);
            sectionBuildings.push(building);
        });

        function createBillboardLabel(section) {
            // Create canvas for the label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            // Background with gradient - lighter for dark text
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            const r = section.color >> 16 & 255;
            const g = section.color >> 8 & 255;
            const b = section.color & 255;
            
            // Lighter gradient for dark text readability
            gradient.addColorStop(0, `rgba(${Math.min(r + 50, 255)}, ${Math.min(g + 50, 255)}, ${Math.min(b + 50, 255)}, 0.95)`);
            gradient.addColorStop(1, `rgba(${Math.min(r + 30, 255)}, ${Math.min(g + 30, 255)}, ${Math.min(b + 30, 255)}, 0.85)`);
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add border with dark color
            context.strokeStyle = '#3a1c00'; // Dark brown
            context.lineWidth = 10;
            context.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
            
            // Text with icon - DARK COLORS for better readability
            context.font = 'bold 48px Arial';
            context.fillStyle = '#3a1c00'; // Dark brown text
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.shadowColor = 'rgba(255, 237, 191, 0.8)'; // Light shadow for contrast
            context.shadowBlur = 10;
            
            // Draw icon
            context.font = 'bold 64px Arial';
            context.fillText(section.icon, canvas.width/2 - 100, canvas.height/2);
            
            // Draw title
            context.font = 'bold 48px Arial';
            context.fillText(section.title, canvas.width/2 + 40, canvas.height/2);

            const texture = new THREE.CanvasTexture(canvas);
            const labelGeometry = new THREE.PlaneGeometry(12, 6);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(section.position.x, 10, section.position.z); // Higher for better visibility
            label.userData = { billboard: true };
            scene.add(label);
            sectionLabels.push(label);
        }

        // Physics variables
        let carVelocity = new THREE.Vector3(0, 0, 0);
        let carAcceleration = 0.55;    
        let carDeceleration = 0.9; 
        let maxSpeed = 2.5;              
        let driftFactor = 0.85;
        let turnSpeed = 0.05;             
        let isDrifting = false;
        let driftAngle = 0;
        let isAccelerating = false;
        let isBraking = false;


        // Mobile detection and touch controls
        
        // Touch control variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let isTouching = false;
        let touchStartTime = 0;
        let swipeThreshold = 30; // Minimum distance for swipe detection
        let holdThreshold = 100; // Milliseconds to detect hold vs tap

        // Key states
        const keyStates = {
            w: false,
            s: false,
            a: false,
            d: false
        };

        // Drift trail system
        const driftTrailGeometry = new THREE.PlaneGeometry(0.3, 1.5);
        const driftTrailMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });

        const driftTrails = [];

        function createDriftTrail() {
            if (!car) return;
            
            const trail = new THREE.Mesh(driftTrailGeometry, driftTrailMaterial.clone());
            trail.position.set(car.position.x, 0.1, car.position.z);
            trail.rotation.y = Math.random() * Math.PI * 2;
            
            trail.userData = {
                life: 1.0,
                maxLife: 1.0
            };
            
            scene.add(trail);
            driftTrails.push(trail);
        }

        function updateDriftTrails() {
            for (let i = driftTrails.length - 1; i >= 0; i--) {
                const trail = driftTrails[i];
                trail.userData.life -= 0.03;
                trail.material.opacity = 0.6 * (trail.userData.life / trail.userData.maxLife);
                
                if (trail.userData.life <= 0) {
                    scene.remove(trail);
                    driftTrails.splice(i, 1);
                }
            }
        }

        let car;
        // Load car model
        function createCar() {
            const loader = new GLTFLoader();

            loader.load(
                'car.glb',
                (gltf) => {
                    car = gltf.scene;

                    // Adjust these values to fit your model
                    car.scale.set(1.5, 1.5, 1.5); // Adjusted scale
                    car.position.set(15, 1, 15); // Start position away from center sections
                    car.rotation.y = Math.PI; // Face forward
                    
                    // Enable shadows for all meshes in the model
                    car.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    scene.add(car);
                    console.log('Car loaded successfully');
                },
                (progress) => {
                    console.log(`Loading car: ${Math.round(progress.loaded / progress.total * 100)}%`);
                },
                (error) => {
                    console.error('Error loading car model:', error);
                    // Fallback to simple car if model fails to load
                    createFallbackCar();
                }
            );
        }

        function createFallbackCar() {
            // Simple fallback car
            car = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.BoxGeometry(2.5, 1, 4.5);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff7251,
                emissive: 0xff7251,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            car.add(body);

            // Front indicator
            const frontGeometry = new THREE.BoxGeometry(2.5, 0.4, 0.6);
            const frontMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffcd74,
                emissive: 0xffcd74,
                emissiveIntensity: 0.5
            });
            const front = new THREE.Mesh(frontGeometry, frontMaterial);
            front.position.z = 2.3;
            front.castShadow = true;
            car.add(front);

            // Back indicator
            const backGeometry = new THREE.BoxGeometry(2.5, 0.4, 0.6);
            const backMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x9b2948,
                emissive: 0x9b2948,
                emissiveIntensity: 0.3
            });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.z = -2.3;
            back.castShadow = true;
            car.add(back);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
            const wheelMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                emissive: 0x222222,
                emissiveIntensity: 0.1
            });
            
            const wheelPositions = [
                [0.9, -0.5, 1.5],
                [-0.9, -0.5, 1.5],
                [0.9, -0.5, -1.5],
                [-0.9, -0.5, -1.5]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                car.add(wheel);
            });

            car.position.set(15, 1, 15);
            car.rotation.y = Math.PI;
            scene.add(car);
        }

        // Initialize scene
        createCar();

        // Movement variables
        const moveSpeed = 0.3;
        const rotationSpeed = 0.05;
        const keys = {};

        // Key listeners
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keyStates.hasOwnProperty(key)) {
                keyStates[key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keyStates.hasOwnProperty(key)) {
                keyStates[key] = false;
            }
        });


                // Touch event handlers for mobile
        if (isMobile) {
            // Show mobile hint and controls
            document.getElementById('hint-mobile').style.display = 'inline';
            document.getElementById('hint-desktop').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';

            const touchIndicator = document.querySelector('.touch-circle');
            const touchArrow = document.querySelector('.touch-arrow');

            // Prevent default touch behaviors
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });

            // Touch start
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];

                    // Don't register touch if it's on UI elements
                    const target = e.target;
                    if (target.closest('#section-info') || target.closest('.close-btn')) {
                        return;
                    }

                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchCurrentX = touch.clientX;
                    touchCurrentY = touch.clientY;
                    isTouching = true;
                    touchStartTime = Date.now();

                    // Visual feedback
                    touchIndicator.classList.add('active');
                }
            }, { passive: false });

            // Touch move
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isTouching) {
                    const touch = e.touches[0];
                    touchCurrentX = touch.clientX;
                    touchCurrentY = touch.clientY;

                    const deltaX = touchCurrentX - touchStartX;
                    const deltaY = touchCurrentY - touchStartY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                    // Show direction arrow for swipes
                    if (distance > swipeThreshold) {
                        touchArrow.classList.add('show');
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            if (deltaX > 0) {
                                touchArrow.classList.remove('right');
                                touchArrow.classList.add('left');
                            } else {
                                touchArrow.classList.remove('left');
                                touchArrow.classList.add('right');
                            }
                        }
                    } else {
                        touchArrow.classList.remove('show');
                    }
                }
            }, { passive: false });

            // Touch end
            document.addEventListener('touchend', (e) => {
                isTouching = false;
                touchIndicator.classList.remove('active');
                touchArrow.classList.remove('show');
                touchArrow.classList.remove('left');
                touchArrow.classList.remove('right');
            }, { passive: false });

            // Also handle touch cancel
            document.addEventListener('touchcancel', (e) => {
                isTouching = false;
                touchIndicator.classList.remove('active');
                touchArrow.classList.remove('show');
            }, { passive: false });
        }

        // Section detection
        let currentSection = null;
        let boundaryWarningTimeout = null;

        function checkSectionCollision() {
            if (!car) return;
                
            // Don't check if panel is in cooldown or animating
            if (panelCooldown || isPanelAnimating) return;
                
            const carPos = car.position;
            let foundSection = false;
                
            for (const [key, section] of Object.entries(sections)) {
                const sectionBounds = {
                    x: {
                        min: section.position.x - section.size.x / 2,
                        max: section.position.x + section.size.x / 2
                    },
                    z: {
                        min: section.position.z - section.size.y / 2,
                        max: section.position.z + section.size.y / 2
                    }
                };
            
                if (carPos.x > sectionBounds.x.min && carPos.x < sectionBounds.x.max &&
                    carPos.z > sectionBounds.z.min && carPos.z < sectionBounds.z.max) {
                    
                    foundSection = true;
                    
                    // Only open if it's a different section or panel is closed
                    if (currentSection !== key) {
                        showSectionInfo(key);
                    }
                    return;
                }
            }
            
            // If car leaves all sections and panel is open, close it
            if (currentSection !== null && !foundSection && !panelCooldown) {
                hideSectionInfo();
            }
        }

        let currentPanelAnimation = null;
        let isPanelAnimating = false;

        // Panel control variables
        let panelCooldown = false;
        let panelCooldownTimeout = null;

        function showSectionInfo(sectionKey) {
            // Don't open if in cooldown period
            if (panelCooldown) return;

            // Don't open if it's the same section already showing
            if (currentSection === sectionKey) return;

            // Reset animation flags
            if (isPanelAnimating) return;

             // NEW: On mobile, prevent touch events from propagating to canvas when panel is open
            if (isMobile) {
                const sectionInfo = document.getElementById('section-info');
                sectionInfo.style.pointerEvents = 'auto';
            }

            isPanelAnimating = true;
            const section = sections[sectionKey];
            const sectionContent = document.getElementById('section-content');
            const sectionInfo = document.getElementById('section-info');

            // Remove any previous animation classes
            sectionInfo.classList.remove('panel-show');
            sectionContent.classList.remove('section-content-animate');

            // Clear any existing timeout
            if (currentPanelAnimation) {
                clearTimeout(currentPanelAnimation);
                currentPanelAnimation = null;
            }

            // Clear any cooldown
            if (panelCooldownTimeout) {
                clearTimeout(panelCooldownTimeout);
                panelCooldown = false;
            }

            // Set the new content
            sectionContent.innerHTML = section.content;

            // Force a reflow to ensure transition works
            void sectionInfo.offsetWidth;

            // Add the show class to trigger slide-in animation
            sectionInfo.classList.add('panel-show');

            // After panel slides in, animate the content
            currentPanelAnimation = setTimeout(() => {
                sectionContent.classList.add('section-content-animate');

                // Reset animation state after animation completes
                setTimeout(() => {
                    isPanelAnimating = false;
                    currentPanelAnimation = null;
                }, 800);

            }, 300); // Delay content animation until panel is mostly in

            // Highlight the section in 3D scene
            highlightSection(sectionKey);
            currentSection = sectionKey;
        }
        
        function hideSectionInfo() {
            isPanelAnimating = true;
            const sectionInfo = document.getElementById('section-info');
            const sectionContent = document.getElementById('section-content');

            if (!sectionInfo.classList.contains('panel-show')) {
                isPanelAnimating = false;
                return;
            }

            // Start cooldown period to prevent immediate re-open
            panelCooldown = true;
            if (panelCooldownTimeout) {
                clearTimeout(panelCooldownTimeout);
            }

            // Set cooldown for 1.5 seconds
            panelCooldownTimeout = setTimeout(() => {
                panelCooldown = false;
                panelCooldownTimeout = null;
            }, 1500);

            // Fade out content first
            sectionContent.style.opacity = '0';
            sectionContent.style.transform = 'translateY(10px)';

            // Then slide out panel
            setTimeout(() => {
                sectionInfo.classList.remove('panel-show');
                sectionContent.classList.remove('section-content-animate');

                // Clear current section immediately
                currentSection = null;
                removeSectionHighlight();

                // Clear content after animation completes
                setTimeout(() => {
                    if (!sectionInfo.classList.contains('panel-show')) {
                        sectionContent.innerHTML = '';
                        sectionContent.style.opacity = '1';
                        sectionContent.style.transform = 'translateY(0)';
                    }
                    isPanelAnimating = false;
                }, 500);
            }, 200);
        }

        function highlightSection(sectionKey) {
            // Remove any existing highlights
            removeSectionHighlight();

            // Find the section mesh and highlight it
            sectionMeshes.forEach(mesh => {
                if (mesh.userData.id === sectionKey) {
                    // Store original material properties
                    mesh.userData.originalEmissive = mesh.material.emissive.getHex();
                    mesh.userData.originalOpacity = mesh.material.opacity;

                    // Apply highlight
                    mesh.material.emissive.setHex(0xffffff);
                    mesh.material.emissiveIntensity = 0.8;
                    mesh.material.opacity = 1.0;

                    // Add pulsing animation
                    let pulseTime = 0;
                    const pulseMaterial = mesh.material;

                    function pulseAnimation() {
                        if (mesh.userData.isHighlighted) {
                            pulseTime += 0.05;
                            const pulse = Math.sin(pulseTime) * 0.2 + 0.8;
                            pulseMaterial.emissiveIntensity = 0.6 + pulse * 0.4;
                            requestAnimationFrame(pulseAnimation);
                        }
                    }

                    mesh.userData.isHighlighted = true;
                    mesh.userData.pulseAnimation = pulseAnimation;
                    pulseAnimation();
                }
            });
        }

        function removeSectionHighlight() {
            sectionMeshes.forEach(mesh => {
                if (mesh.userData.originalEmissive !== undefined) {
                    mesh.material.emissive.setHex(mesh.userData.originalEmissive);
                    mesh.material.emissiveIntensity = 0.4;
                    mesh.material.opacity = mesh.userData.originalOpacity;
                    mesh.userData.isHighlighted = false;
                    delete mesh.userData.pulseAnimation;
                }
            });
        }

        // Billboard effect: Make labels always face camera
        function updateBillboards() {
            sectionLabels.forEach(label => {
                label.lookAt(camera.position);
            });
        }

        // Check if position is within boundaries
        function isWithinBoundaries(x, z) {
            return x > BOUNDARY.minX && x < BOUNDARY.maxX &&
                   z > BOUNDARY.minZ && z < BOUNDARY.maxZ;
        }

        // Add visual boundary markers
        function addBoundaryMarkers() {
            const boundaryMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff7251,
                transparent: true,
                opacity: 0.2,
                linewidth: 2
            });
            
            // Create boundary lines
            const boundaryPoints = [
                new THREE.Vector3(BOUNDARY.minX, 0.5, BOUNDARY.minZ),
                new THREE.Vector3(BOUNDARY.maxX, 0.5, BOUNDARY.minZ),
                new THREE.Vector3(BOUNDARY.maxX, 0.5, BOUNDARY.maxZ),
                new THREE.Vector3(BOUNDARY.minX, 0.5, BOUNDARY.maxZ),
                new THREE.Vector3(BOUNDARY.minX, 0.5, BOUNDARY.minZ)
            ];
            
            const boundaryGeometry = new THREE.BufferGeometry().setFromPoints(boundaryPoints);
            const boundaryLine = new THREE.Line(boundaryGeometry, boundaryMaterial);
            scene.add(boundaryLine);
        }

        const dustParticles = [];
        const dustGeometry = new THREE.SphereGeometry(0.1, 4, 4);
        const dustMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffcd74,
            transparent: true,
            opacity: 0.7
        });

        function createDustParticles() {
            if (!car) return;

            // Create 1-3 dust particles per frame when moving
            const particleCount = Math.floor(Math.random() * 3) + 1;

            for (let i = 0; i < particleCount; i++) {
                const dust = new THREE.Mesh(dustGeometry, dustMaterial);

                // Position behind the car (adjust based on car's direction)
                const offsetX = Math.sin(car.rotation.y + Math.PI) * 1.5 + (Math.random() - 0.5) * 0.5;
                const offsetZ = Math.cos(car.rotation.y + Math.PI) * 1.5 + (Math.random() - 0.5) * 0.5;

                dust.position.set(
                    car.position.x + offsetX,
                    0.2,
                    car.position.z + offsetZ
                );

                dust.userData = {
                    life: 1.0,
                    velocity: new THREE.Vector3(
                        -carVelocity.x * 0.1 + (Math.random() - 0.5) * 0.05,
                        0.05 + Math.random() * 0.05,
                        -carVelocity.z * 0.1 + (Math.random() - 0.5) * 0.05
                    ),
                    rotationSpeed: (Math.random() - 0.5) * 0.1
                };

                scene.add(dust);
                dustParticles.push(dust);
            }
        }

        // Update dust particles in animation loop
        function updateDustParticles() {
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const particle = dustParticles[i];

                particle.userData.life -= 0.02;
                particle.position.add(particle.userData.velocity);
                particle.userData.velocity.y -= 0.002; // Gravity
                particle.rotation.x += particle.userData.rotationSpeed;
                particle.rotation.y += particle.userData.rotationSpeed;

                // Fade out
                particle.material.opacity = particle.userData.life * 0.7;
                particle.scale.setScalar(0.5 + particle.userData.life * 0.5);

                // Remove dead particles
                if (particle.userData.life <= 0 || particle.position.y < 0) {
                    scene.remove(particle);
                    dustParticles.splice(i, 1);
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Car movement with boundary checking
                if (car) {
                // Calculate forward direction
                const forward = new THREE.Vector3(
                    -Math.sin(car.rotation.y),
                    0,
                    -Math.cos(car.rotation.y)
                );
                        
                // Desktop controls (WASD)
                if (!isMobile) {
                    // Apply acceleration
                    if (keyStates.w) {
                        carVelocity.add(forward.clone().multiplyScalar(-carAcceleration * 0.1));
                        isAccelerating = true;
                    } else if (keyStates.s) {
                        carVelocity.add(forward.clone().multiplyScalar(carAcceleration * 0.08));
                        isBraking = true;
                    } else {
                        isAccelerating = false;
                        isBraking = false;
                    }
                
                    // Apply steering
                    if (keyStates.a) {
                        car.rotation.y += turnSpeed * (Math.min(carVelocity.length(), 0.5) / 0.5);
                    }
                    if (keyStates.d) {
                        car.rotation.y -= turnSpeed * (Math.min(carVelocity.length(), 0.5) / 0.5);
                    }
                } 
                // Mobile touch controls
                else {
                    if (isTouching) {
                        const touchDuration = Date.now() - touchStartTime;
                        const deltaX = touchCurrentX - touchStartX;
                        const deltaY = touchCurrentY - touchStartY;
                        const swipeDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        // Holding = accelerate forward
                        carVelocity.add(forward.clone().multiplyScalar(-carAcceleration * 0.1));
                        isAccelerating = true;
                        
                        // Swipe detection for turning (REVERSED)
                        if (swipeDistance > swipeThreshold) {
                            const swipeAngle = Math.atan2(deltaY, deltaX);
                            const horizontalSwipe = Math.abs(Math.cos(swipeAngle));
                            
                            // If swipe is mostly horizontal
                            if (horizontalSwipe > 0.7) {
                                const turnIntensity = Math.min(swipeDistance / 100, 1.5);
                                
                                if (deltaX > 0) {
                                    // Swipe right = turn left
                                    car.rotation.y += turnSpeed * turnIntensity * (Math.min(carVelocity.length(), 0.5) / 0.5);
                                } else {
                                    // Swipe left = turn right
                                    car.rotation.y -= turnSpeed * turnIntensity * (Math.min(carVelocity.length(), 0.5) / 0.5);
                                }
                            }
                        }
                    } else {
                        isAccelerating = false;
                        isBraking = false;
                    }
                }
        
            // Apply friction/drag (same for both)
            carVelocity.multiplyScalar(carDeceleration);
        
            // Limit max speed
            if (carVelocity.length() > maxSpeed) {
                carVelocity.setLength(maxSpeed);
            }
        
            // Detect drift state
            const speed = carVelocity.length();

            if (!isMobile) {
                isDrifting = speed > 0.5 && (keyStates.a || keyStates.d);
            } else {
                // Mobile drift detection based on turn rate
                const deltaX = touchCurrentX - touchStartX;
                isDrifting = isTouching && speed > 0.5 && Math.abs(deltaX) > swipeThreshold * 1.5;
            }

            if (isDrifting) {
                const velocityDir = carVelocity.clone().normalize();
                const blendedDir = velocityDir.lerp(forward, 0.08);
                carVelocity.copy(blendedDir.multiplyScalar(speed));
                if (Math.random() > 0.5) createDriftTrail();

                if (!isMobile) {
                    driftAngle = keyStates.a ? 0.3 : (keyStates.d ? -0.3 : 0);
                } else {
                    const deltaX = touchCurrentX - touchStartX;
                    driftAngle = (deltaX > 0 ? -0.3 : 0.3);
                }
            } else {
                driftAngle = 0;
            }
        
            // Car tilt effect
            car.rotation.z = driftAngle * 0.3;
        
            // Update position with boundary checking
            const newX = car.position.x + carVelocity.x;
            const newZ = car.position.z + carVelocity.z;
        
            if (isWithinBoundaries(newX, newZ)) {
                car.position.x = newX;
                car.position.z = newZ;
            } else {
                // Bounce off boundaries with energy loss
                carVelocity.multiplyScalar(-0.3);
            }
        
            // Create dust VFX when moving
            if (carVelocity.length() > 0.1) {
                createDustParticles();
            }
        }
            // Update dust particles and drift trails
            updateDustParticles();
            updateDriftTrails();

            // Check section collision
            checkSectionCollision();

            // Update billboards to face camera
            updateBillboards();

            // Update OrbitControls
            controls.update();

            renderer.render(scene, camera);
        }


        if (isMobile) {
            // Reduce shadow quality on mobile
            renderer.shadowMap.enabled = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;

            // Reduce antialiasing on mobile if needed
            if (window.devicePixelRatio > 2) {
                renderer.setPixelRatio(2);
            }

            // Disable orbit controls damping on mobile for better performance
            controls.enableDamping = false;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            
            // Add boundary markers
            addBoundaryMarkers();
            
            // Add some decorative elements
            addDecorativeElements();
            
            animate();
        }, 1000);

        // Add decorative elements
        function addDecorativeElements() {
            // Add subtle background particles
            const particleCount = 30;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 120;
                positions[i + 1] = Math.random() * 30 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 120;
                
                // Warm colors
                colors[i] = 0.8 + Math.random() * 0.2;
                colors[i + 1] = 0.6 + Math.random() * 0.3;
                colors[i + 2] = 0.3 + Math.random() * 0.2;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }

        // Make hideSectionInfo available globally
        window.hideSectionInfo = function() {
            hideSectionInfo();
        };

       
    </script>
</body>
</html>